
const fs= require( 'fs' );
const path= require( 'path' );

const sqlite3 = require('sqlite3').verbose();
const cron= require('node-cron');
const { send } = require('process');


let hereLog= (...args) => {console.log("[utils]", ...args);};

JSONCheck ={
    VERSION: 0b1,
    BUILD: 0b10,

    TOKEN: 0b100,

    MASTERID: 0b1000,

    FULL_CHECK: 0b1111,

    availability: JSONobject => {
        let r= 0b0;

        let testEmptyFn= (str, CTRL) => { if(str.length>0) r= r | CTRL;}

        testEmptyFn(JSONobject.version, JSONCheck.VERSION);
        testEmptyFn(JSONobject.build, JSONCheck.BUILD);
        testEmptyFn(JSONobject.token, JSONCheck.TOKEN);

        let testMatchFn= (str, regex, CTRL) => {
            if((str.length>0) && (str.match(regex)!==null)) { r= r | CTRL;}
        }
        let idRegexMatch= /^[0-9]{18}$/;

        testMatchFn(JSONobject.masterID, idRegexMatch, JSONCheck.MASTERID);

        return r;
    },

    validity: JSONobject => {
        let r= JSONCheck.availability(JSONobject);

        return ( r === JSONCheck.FULL_CHECK );
    },

    report: JSONobject => {
        let r= JSONCheck.availability(JSONobject);

        if( r === JSONCheck.FULL_CHECK ){
            return "JSON Settings correctly available";
        }

        let str= "Error generated by: ";
        
        let reportConcat= (CTRL, fieldName) => {
            if ( !(r & CTRL) ){
                str+= "\n\tJSON settings - "+fieldName;
            }
        }

        reportConcat(JSONCheck.VERSION, "version");
        reportConcat(JSONCheck.BUILD, "build");
        reportConcat(JSONCheck.TOKEN, "token");
        reportConcat(JSONCheck.MASTERID, "masterID");

        return str;
    },
};

function loadJSONFile(filepath){
    try{
        if(fs.existsSync(filepath)){
            var data= fs.readFileSync(filepath);

            var r= undefined;
            if(Boolean(data) && Boolean(r=JSON.parse(data))){
                return r;
            }
            else{
                hereLog(`[load_json]('${filepath}') Error reading data from file`);
                return undefined;
            }
        }
        else{
            hereLog(`[load_json]('${filepath}')  Error reading data; file doesn't seem to existsâ€¦'`);
            return undefined;
        }
    } catch(err){
        hereLog(`[load_json]('${filepath}') Critical erreur reading data from fileâ€¦\n\t${err}`)
        return undefined
    }
}

function writeJSON(data, filepath) {
    try {
        const jsonData = JSON.stringify(data, null, 2);

        fs.writeFileSync(filepath, jsonData);

        return filepath
    } catch (error) {
        hereLog(`[load_json]('${filepath}') Error writing data:\n\t${error}`);
        return undefined
    }
}

function commandDecompose(message, prefix='!'){
    if(!message.content.startsWith(prefix)){
        return null;
    }

    let splitCmd= message.content.substr(1).split(/[ ]+/);
    return {
        'command': splitCmd[0].toLowerCase(),
        'args': splitCmd.slice(1),
        'msg_obj': message,
    }
}

function commandNameFromFilePath(fpath){
    var cmd_name= path.basename(fpath);
    cmd_name= (cmd_name.startsWith("cmd_"))? cmd_name.slice(4) : cmd_name;
    cmd_name= (cmd_name.endsWith(".js"))? cmd_name.slice(0,-3) : cmd_name;

    return cmd_name;
}

function commandArgsOptionsExtract(args, optionPrefix='?'){
    var i=0;
    var options= {}
    var left_args= []
    while(i<args.length){
        var arg= args[i]
        var rm_args= []
        if(arg.startsWith(optionPrefix) && arg.length>1){
            var joined_rest= args.slice(i).join(' ').slice(1)
            
            var opt_name=""
            var opt_val=""

            const _States={
                READ_OPT_NAME: 0,
                EXPECTING_EQ: 1,
                READ_OPT_VAL: 0b010,
                EXPECTING_END_QM: 0b100
            }

            var option= {name: ""}
            var state= _States.READ_OPT_NAME;
            var j= 0;
            while(j<joined_rest.length){
                var char= joined_rest[j]
                if(state===_States.READ_OPT_NAME){
                    if(char===' '){
                        state= _States.EXPECTING_EQ;
                    }
                    else if(char==='='){
                        state= _States.READ_OPT_VAL
                    }
                    else{
                        opt_name+= char;
                    }
                }
                else if(state===_States.EXPECTING_EQ){
                    if(char==='='){
                        state= _States.READ_OPT_VAL
                    }
                    else if(char!==' '){
                        ++j
                        break;
                    }
                }
                else if(state & _States.READ_OPT_VAL){
                    if(char==='"'){
                        if([' ','='].includes(joined_rest[j-1]) && !(state & _States.EXPECTING_END_QM)){
                            state= state | _States.EXPECTING_END_QM
                        }
                        else if((state & _States.EXPECTING_END_QM) && !(joined_rest.length>(j+1) && joined_rest[j+1]!==' ')){
                            ++j
                            break;
                        }
                        else{
                            opt_val+= char
                        }
                    }
                    else if(char===' '){
                        if(!(state & _States.EXPECTING_END_QM) && opt_val.length>0){
                            ++j
                            break;
                        }
                        else{
                            opt_val+= char
                        }
                    }
                    else{
                        opt_val+= char
                    }
                }

                ++j
            }

            option.name= opt_name;
            option['value']= (opt_val.length===0)?
                    (((state & _States.EXPECTING_END_QM) && joined_rest[j-1]==='"')?"":undefined)
                :   opt_val; 

            if(Boolean(option.value)){
                options[option.name]= option.value
            }

            var ul=
                (joined_rest[j-1]===' ' || ((state & _States.EXPECTING_END_QM) && joined_rest[j-1]==='"') )?j-1
                : ((state===_States.EXPECTING_EQ) && joined_rest[j-2]===' ')? j-2    
                : j;
            rm_args= joined_rest.slice(0,ul).split(' ')
            // hereLog(`\t\trm_args: ${rm_args}`)
        }
        else{
            left_args.push(arg)
        }

        if(rm_args.length>0){
            i+= rm_args.length
        }
        else{
            ++i
        }
    }
    // return options

    return {options: options, args: left_args}
}


/**
 * from https://github.com/discordjs/discord.js/blob/v13/src/util/Util.js
 */
/**
 * Options for splitting a message.
 * @typedef {Object} SplitOptions
 * @property {number} [maxLength=2000] Maximum character length per message piece
 * @property {string|string[]|RegExp|RegExp[]} [char='\n'] Character(s) or Regex(es) to split the message with,
 * an array can be used to split multiple times
 * @property {string} [prepend=''] Text to prepend to every piece except the first
 * @property {string} [append=''] Text to append to every piece except the last
 */

/**
 * Splits a string into multiple chunks at a designated character that do not exceed a specific length.
 * @param {string} text Content to split
 * @param {SplitOptions} [options] Options controlling the behavior of the split
 * @returns {string[]}
 */
function splitMessage(text, { maxLength = 2_000, char = '\n', prepend = '', append = '' } = {}) {
    if (text.length <= maxLength) return [text];
    let splitText = [text];
    if (Array.isArray(char)) {
      while (char.length > 0 && splitText.some(elem => elem.length > maxLength)) {
        const currentChar = char.shift();
        if (currentChar instanceof RegExp) {
          splitText = splitText.flatMap(chunk => chunk.match(currentChar));
        } else {
          splitText = splitText.flatMap(chunk => chunk.split(currentChar));
        }
      }
    } else {
      splitText = text.split(char);
    }
    if (splitText.some(elem => elem.length > maxLength)) throw new RangeError('SPLIT_MAX_LEN');
    const messages = [];
    let msg = '';
    for (const chunk of splitText) {
      if (msg && (msg + char + chunk + append).length > maxLength) {
        messages.push(msg + append);
        msg = prepend;
      }
      msg += (msg && msg !== prepend ? char : '') + chunk;
    }
    return messages.concat(msg).filter(m => m);
}

async function splitSend(sendTarget, msg, {chainReply=false, prepend = '', append = ''}= {}){
    if(msg.length<2000) return sendTarget.send(msg)


    var chunkmessages= splitMessage(msg, {prepend,append})
    var m= undefined
    var retMessages= []
    while(chunkmessages.length>0){
        let chunk= chunkmessages.shift()
        if(chainReply && Boolean(m))
            m= await m.reply(chunk)
        else
            m= await sendTarget.send(chunk)
        retMessages.push(m)
    }

    return retMessages
}


class DataBaseManager{
    constructor(dbFilepath){
        this._db_path= dbFilepath

        this._db= null
        this._db_closeStamp= undefined

        this._cron_db_closer= cron.schedule('*/5 * * * *', () =>{
            if(Boolean(this._db_closeStamp) && ((Date.now()-this._db_closeStamp)>120000)
                && Boolean(this._db)
            ){
                this._db.close()
                hereLog("[DB_Manager]Closing databaseâ€¦")
                this._db= null
                this._db_closeStamp= undefined
            }
        });
    }

    _open_db(){
        if(!Boolean(this._db)){
            this._db_closeStamp= undefined
            this._db= new sqlite3.Database( this._db_path, (err) =>{
                if(err){
                    hereLog(err.message)
                    this._db_closeStamp= Date.now()-5000
                }
    
                hereLog(`[DB_Manager]Connection to ${this._db_path}`)
            })
        }
        else{
            this._db_closeStamp= undefined
        }
    }

    _closeRequest_db(){
        this._db_closeStamp= Date.now()
    }

    _is_db_open(){ return Boolean(this._db);}

    __runQuery(query, placeholders=[]){
        return new Promise((resolve, reject)=>{
            if(!this._is_db_open()) resolve(false);
            else{
                this._db.run(query,placeholders,(err)=>{
                    if(Boolean(err)){
                        hereLog(`[DB_Manager][RunQuery] query: ${query}; placeholders: ${placeholders}; error: ${err.message}`)
                        resolve(false);
                    }

                    resolve(true)
                })
            }
        })
    }

    __allQuery(query, fn, placeholders=[]){
        return new Promise((resolve, reject)=>{
            if(!this._is_db_open()) resolve(false);
            else{
                this._db.all(query, placeholders, async (err, rows)=>{
                    if(Boolean(err)){
                        hereLog(`[DB_Manager][eachQuery] query: ${query}; placeholders: ${placeholders}; error: ${err.message}`)
                        resolve(false);
                    }

                    if(Boolean(fn) && Boolean(rows)){
                        for(var row of rows){
                            await fn(row);
                        }
                    }

                    resolve(true);
                })
            }
        })
    }

    __getQuery(query,placeholders=[]){
        return new Promise((resolve, reject)=>{
            if(!this._is_db_open()) resolve(undefined);
            else{
            var t= this;
                this._db.serialize(function(){
                    t._db.get(query,placeholders,(err,row)=>{
                        if(Boolean(err)){
                            hereLog(`[DB_Manager][getQuery] query: ${query} ; placeholders: ${placeholders}; error: ${err.message}`)
                            resolve(undefined)
                        }
                        resolve(row)
                    })
                })
            }
        })
    }
}

function sleep(ms=1000){
    return new Promise(resolve => setTimeout(resolve, ms))
}

function DateFromTimeZone(dateString, timezone="Europe/Paris"){
    var baseDate= new Date(dateString)
    var tzPoVDate= new Date(baseDate.toLocaleString('en-US', {
        timeZone: timezone
    }))

    var diff= baseDate.getTime() - tzPoVDate.getTime()

    return new Date(baseDate.getTime() + diff)
}


let _fightersOBJ= undefined

function _loadFightersObj(filepath){
    var fn= path.resolve(`${filepath}`)
    if(fs.existsSync(fn)){
        try{
            var data= fs.readFileSync(fn);
        } catch(err){
            hereLog(`[load_fighters] Couldn't read '${fn}'`)
        }

        var r= undefined;
        if(Boolean(data) && Boolean(r=JSON.parse(data))){
            _fightersOBJ= r;
        }
        else{
            hereLog(`[load_fighters] Error reading data from '${fn}'`);
        }

        return _fightersOBJ
    }
    else{
        hereLog(`[load_fighters]'${fn}' file not found`);

        return undefined
    }
}



function identifyEmoji(str, utils){
    let simpleEmojiRegex= /(?:[\u2700-\u27bf]|(?:\ud83c[\udde6-\uddff]){2}|[\ud800-\udbff][\udc00-\udfff]|[\u0023-\u0039]\ufe0f?\u20e3|\u3299|\u3297|\u303d|\u3030|\u24c2|\ud83c[\udd70-\udd71]|\ud83c[\udd7e-\udd7f]|\ud83c\udd8e|\ud83c[\udd91-\udd9a]|\ud83c[\udde6-\uddff]|\ud83c[\ude01-\ude02]|\ud83c\ude1a|\ud83c\ude2f|\ud83c[\ude32-\ude3a]|\ud83c[\ude50-\ude51]|\u203c|\u2049|[\u25aa-\u25ab]|\u25b6|\u25c0|[\u25fb-\u25fe]|\u00a9|\u00ae|\u2122|\u2139|\ud83c\udc04|[\u2600-\u26FF]|\u2b05|\u2b06|\u2b07|\u2b1b|\u2b1c|\u2b50|\u2b55|\u231a|\u231b|\u2328|\u23cf|[\u23e9-\u23f3]|[\u23f8-\u23fa]|\ud83c\udccf|\u2934|\u2935|[\u2190-\u21ff])/g;
    let customEmojiRegex= /^<\:([a-zA-Z\-_0-9]+)\:([0-9]{18})>$/;

    var _tmp= undefined;
    var emojiType= undefined;
    try{
        emojiType= ( Boolean(str) )? (
                Boolean(str.match(simpleEmojiRegex))? {type: "SIMPLE", emoji: str, text: str} :
                    ( Boolean(str) && Boolean(_tmp=str.match(customEmojiRegex))? 
                            {   type: "CUSTOM",
                                emoji: utils.getBotClient().emojis.cache.get(_tmp[2]),
                                text: str
                            }
                        : undefined) 
            ) : undefined;
    }
    catch(err){
        hereLog(`[identifyEmoji] error: ${err.message}`)
        emojiType= undefined;
    }

    return emojiType;
}

function processMention(str){
    let rx_channelMention_id= /<#(\d+)>/
    let rx_userMention_id= /<@(\d+)>/
    let rx_roleMention_id= /<@&(\d+)>/

    var m= undefined
    if(Boolean(m=str.match(rx_userMention_id))) return {type: 'user', id: m[1]}
    if(Boolean(m=str.match(rx_channelMention_id))) return {type: 'channel', id: m[1]}
    if(Boolean(m=str.match(rx_roleMention_id))) return {type: 'role', id: m[1]}
    return undefined
}

let Flags={
    MissingAuth: {
        NONE: 0,
        USER: 1,
        CHANNEL: 2,
        ROLE: 4,
        NO_DATA: 8,

        MASTER_PRIVILEDGES: 256
    }
}

let Enums={
    CmdRetCode: {
        MASTER_PRIVILEDGES: -1,
        SUCCESS: 0,
        BAD_USER: 1,
        BAD_CHANNEL: 2,
        BAD_ROLE: 3,
        NO_AUTH_SPECIFIED: 4,
        ERROR_INPUT: 5,
        ERROR_REFUSAL: 6,
        ERROR_INTERNAL: 7,
        ERROR_CRITICAL: 8
    }
}

function MissingAuthFlag_to_CmdRetCode(mf, allowNoAuthData=true){
    let b_noData= (mf===undefined || (mf & Flags.MissingAuth.NO_DATA))
    if((mf===Flags.MissingAuth.NONE) || (allowNoAuthData && b_noData)) return Enums.CmdRetCode.SUCCESS
    if(Boolean(mf) && (mf & Flags.MissingAuth.MASTER_PRIVILEDGES)) return Enums.CmdRetCode.MASTER_PRIVILEDGES
    if(b_noData) return Enums.CmdRetCode.NO_AUTH_SPECIFIED
    if(mf & Flags.MissingAuth.CHANNEL) return Enums.CmdRetCode.BAD_CHANNEL
    if(mf & Flags.MissingAuth.USER) return Enums.CmdRetCode.BAD_USER
    if(mf & Flags.MissingAuth.ROLE) return Enums.CmdRetCode.BAD_ROLE
    return Enums.CmdRetCode.ERROR_INTERNAL
}

let AuthAllowed_noData = mf => (
    (mf===undefined) || (mf===Flags.MissingAuth.NONE) || Boolean(mf & Flags.MissingAuth.NO_DATA) || Boolean(mf & Flags.MissingAuth.MASTER_PRIVILEDGES)
)

let AuthAllowed_dataOnly = mf => (
    Boolean(mf & Flags.MissingAuth.MASTER_PRIVILEDGES) || !Boolean(mf)
)

function emoji_retCode(rcode){
    if(rcode===undefined) return undefined
    if(rcode===Enums.CmdRetCode.SUCCESS || rcode===true) return 'âœ…';
    if(rcode===Enums.CmdRetCode.MASTER_PRIVILEDGES) return 'â˜‘ï¸';
    if(rcode===Enums.CmdRetCode.BAD_USER) return 'ðŸš·';
    if(rcode===Enums.CmdRetCode.BAD_CHANNEL) return 'â›”';
    if(rcode===Enums.CmdRetCode.BAD_ROLE) return 'ðŸ†–';
    if(rcode===Enums.CmdRetCode.NO_AUTH_SPECIFIED) return 'â—»';
    if(rcode===Enums.CmdRetCode.ERROR_INPUT) return 'â“';
    if(rcode===Enums.CmdRetCode.ERROR_REFUSAL) return 'ðŸ›‘';
    if(rcode===Enums.CmdRetCode.ERROR_INTERNAL) return 'âš ';
    if(rcode===Enums.CmdRetCode.ERROR_CRITICAL) return 'ðŸ’¥';
    return 'âŒ';
}

function strMatchesDiscordID(str){
    return Boolean(str.match(/^[0,9]{15-21}$/));
}

function getFromFieldPath(obj, fieldpath, separator='.'){
    if((!fieldpath) || !obj) return obj

    var path= (Array.isArray(fieldpath))?
                                fieldpath.filter(e => e.length>0)
                            :   fieldpath.split(separator).filter(e => e.length>0)

    if(path.length<=0) return value;

    let hasBracketAccess= (s) => {
        let _s= s.split('[')
        if(_s.length<2) return undefined;
        else if(!_s.at(-1).endsWith(']')) return undefined;
        else{
            return [
                _s[0],
                ( _s.slice(1).join('[').slice(0,-1))
            ]

        }
    }
    var index= 0;
    while(index<path.length){
        var n= path[index]
        var pair= undefined

        if(Boolean(pair=hasBracketAccess(n))){
            path.splice(index,1,pair[0],pair[1])
            index+=2
        }
        else index ++
    }

    var value= obj
    var node = path.shift()
    while(node){
        value= value[node]
        if((!Boolean(value)) && value!==''){
            return undefined
        }

        node= path.shift()
    }

    return value
}

function formatBytes(bytes) {
    const sizes = ['Bytes', 'KB', 'MB', 'GB', 'TB'];
    if (bytes === 0) return '0 Bytes';
    
    const i = Math.floor(Math.log(bytes) / Math.log(1024)); // Determine size index
    const formattedSize = (bytes / Math.pow(1024, i)).toFixed(1); // Divide by appropriate factor
    
    return `${formattedSize} ${sizes[i]}`;
}

function checkUrl(str){
    try{
        return new URL(str)
    }
    catch(err){
        return undefined
    }
}

module.exports.JSONCheck= JSONCheck;
module.exports.loadJSONFile= loadJSONFile;
module.exports.writeJSON= writeJSON;
module.exports.commandDecompose= commandDecompose;
module.exports.commandNameFromFilePath= commandNameFromFilePath;
module.exports.commandArgsOptionsExtract= commandArgsOptionsExtract;
module.exports.splitMessage= splitMessage;
module.exports.splitSend= splitSend;
module.exports.DataBaseManager= DataBaseManager;
module.exports.sleep= sleep;
module.exports.DateFromTimeZone= DateFromTimeZone;
module.exports.identifyEmoji= identifyEmoji;
module.exports.processMention= processMention;
module.exports.Flags= Flags;
module.exports.Enums= Enums;
module.exports.MissingAuthFlag_to_CmdRetCode= MissingAuthFlag_to_CmdRetCode;
module.exports.AuthAllowed_noData= AuthAllowed_noData;
module.exports.AuthAllowed_dataOnly= AuthAllowed_dataOnly;
module.exports.emoji_retCode= emoji_retCode;
module.exports.fighterStuff= {
    getFighters: () => _fightersOBJ,
    loadFighters: _loadFightersObj
}
module.exports.getFromFieldPath= getFromFieldPath;
module.exports.formatBytes= formatBytes;
module.exports.checkUrl= checkUrl
