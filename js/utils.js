
const path= require( 'path' );

const sqlite3 = require('sqlite3').verbose();
const cron= require('node-cron');


let hereLog= (...args) => {console.log("[utils]", ...args);};

JSONCheck ={
    VERSION: 0b1,
    BUILD: 0b10,

    TOKEN: 0b100,

    MASTERID: 0b1000,

    FULL_CHECK: 0b1111,

    availability: JSONobject => {
        let r= 0b0;

        let testEmptyFn= (str, CTRL) => { if(str.length>0) r= r | CTRL;}

        testEmptyFn(JSONobject.version, JSONCheck.VERSION);
        testEmptyFn(JSONobject.build, JSONCheck.BUILD);
        testEmptyFn(JSONobject.token, JSONCheck.TOKEN);

        let testMatchFn= (str, regex, CTRL) => {
            if((str.length>0) && (str.match(regex)!==null)) { r= r | CTRL;}
        }
        let idRegexMatch= /^[0-9]{18}$/;

        testMatchFn(JSONobject.masterID, idRegexMatch, JSONCheck.MASTERID);

        return r;
    },

    validity: JSONobject => {
        let r= JSONCheck.availability(JSONobject);

        return ( r === JSONCheck.FULL_CHECK );
    },

    report: JSONobject => {
        let r= JSONCheck.availability(JSONobject);

        if( r === JSONCheck.FULL_CHECK ){
            return "JSON Settings correctly available";
        }

        let str= "Error generated by: ";
        
        let reportConcat= (CTRL, fieldName) => {
            if ( !(r & CTRL) ){
                str+= "\n\tJSON settings - "+fieldName;
            }
        }

        reportConcat(JSONCheck.VERSION, "version");
        reportConcat(JSONCheck.BUILD, "build");
        reportConcat(JSONCheck.TOKEN, "token");
        reportConcat(JSONCheck.MASTERID, "masterID");

        return str;
    },
};

function commandDecompose(message, prefix='!'){
    if(!message.content.startsWith(prefix)){
        return null;
    }

    let splitCmd= message.content.substr(1).split(/[ ]+/);
    return {
        'command': splitCmd[0].toLowerCase(),
        'args': splitCmd.slice(1),
        'msg_obj': message,
    }
}

function commandNameFromFilePath(fpath){
    var cmd_name= path.basename(fpath);
    cmd_name= (cmd_name.startsWith("cmd_"))? cmd_name.slice(4) : cmd_name;
    cmd_name= (cmd_name.endsWith(".js"))? cmd_name.slice(0,-3) : cmd_name;

    return cmd_name;
}

function commandArgsOptionsExtract(args, optionPrefix='?'){
    // var cursor= 0
    // var i=0
    // var options= []
    // var remove_args=[]
    // while(i<args.length){
    //     var new_option=undefined
    //     cursor=i;
    //     var arg= args[i]
    //     var eq_met= false
    //     if(arg.startsWith(optionPrefix) && arg.length>1){
    //         var buff="";
    //         if(arg.endsWith('=')){
    //             new_option={name: arg.slice(1,-1), value: undefined}
    //             eq_met= true;
    //         }
    //         else if(arg.includes('=')){
    //             var _tmp= arg.slice(1).split('=')
    //             buff= _tmp.slice(1).join('=')
    //             new_option={name: _tmp[0], value: undefined}
    //             eq_met= true;
    //         }
    //         else{
    //             new_option={name: arg.slice(1), value: undefined}
    //         }
    //         remove_args.push(arg)

    //         if(!Boolean(new_option.value)){
    //             ++cursor
    //             var tmp=undefined
    //             if(cursor>=args.length || (Boolean(buff) && (!buff.startsWith('\"') || (buff.length>1 && buff.endsWith('\"'))))){
    //                 arg=undefined;
    //                 tmp= (buff.length>0)?buff:undefined
    //             }
    //             else{
    //                 arg= args[cursor]
    //                 if(arg==='='){
    //                     remove_args.push(arg)
    //                     if(!eq_met){
    //                         ++cursor
    //                         if(cursor<args.length){
    //                             arg= args[cursor]
    //                             tmp= args.slice(cursor).join(' ')
    //                         }
    //                     }
    //                     else{
    //                         tmp= ((buff.length>0)?buff:"")+arg
    //                     }
    //                     eq_met= true;
    //                 }
    //                 else if(arg.startsWith('=')){
    //                     if(!eq_met){
    //                         tmp= args.slice(cursor).join(' ').slice(1);
    //                     }
    //                     else{
    //                         tmp= buff+((buff.length>0)?" ":"")+arg
    //                     }
    //                     eq_met= true;
    //                 }
    //                 else if(arg.startsWith('\"')){
    //                     if(eq_met){
    //                         tmp= buff+((buff.length>0)?" ":"")+args.slice(cursor).join(' ')
    //                     }
    //                     else{
    //                         arg= undefined
    //                     }
    //                 }
    //                 else if(!eq_met){
    //                     arg= undefined
    //                 }
    //                 else{
    //                     tmp= buff+((buff.length>0)?" ":"")+args.slice(cursor).join(' ')
    //                 }
    //                 // hereLog(`\t\t${tmp}`)
    //             }

    //             if(Boolean(tmp)){
    //                 var s_qm_index=-1
    //                 var e_qm_index=-1
    //                 var count_spaces=0

    //                 for(var j=0; j<tmp.length; ++j){
    //                     if(tmp[j]===' '){
    //                         ++count_spaces
    //                     }
    //                     else if(s_qm_index<0 && tmp[j]==='\"'){
    //                         if(j===0 || count_spaces==j){
    //                             s_qm_index= j
    //                         }
    //                         else{
    //                             break;
    //                         }
    //                     }
    //                     else if(e_qm_index<0 && tmp[j]==='\"'
    //                             && !((j+1)<tmp.length && tmp[j+1]!==' '))
    //                     {
    //                         e_qm_index= j
    //                         break;
    //                     }
    //                 }

    //                 // hereLog(`\t\t${s_qm_index} - ${e_qm_index} - ${count_spaces}`)
    //                 if(s_qm_index<0 || e_qm_index<0 ){
    //                     if(Boolean(arg)){
    //                         new_option.value= (arg.startsWith('='))?arg.slice(1):arg;
    //                         remove_args.push(arg)
    //                     }
    //                     else{
    //                         new_option.value= (buff.length>0)?buff:undefined;
    //                     }
    //                     i= cursor
    //                 }
    //                 else{
    //                     new_option.value= tmp.slice(s_qm_index+1, e_qm_index)
    //                     i= cursor+count_spaces
    //                     var _d= (Boolean(arg))?1:0;
    //                     hereLog(`\t\tadd to rm args: ${args.slice(cursor,cursor+count_spaces+_d)} (cur=${cursor},c_space=${count_spaces},_d=${_d},arg=${arg},buff=${buff})`)
    //                     remove_args= remove_args.concat(args.slice(cursor,cursor+count_spaces+_d))
    //                 }
    //             }
    //             else{
    //                 new_option.value= (Boolean(arg) && arg.startsWith('='))?arg.slice(1):arg;
    //             }
    
    //         }
    //         options.push(new_option);
    //     }
    //     ++i
    // }

    // var left_args=[]
    // hereLog(`\t\trm_args ${remove_args}`)
    // for(var j=0; (j<args.length); ++j){
    //     var arg= args[j]
    //     if(remove_args.length>0 && arg===remove_args[0]){
    //         remove_args.shift()
    //     }
    //     else{
    //         left_args.push(arg)
    //     }
    // }

    var i=0;
    var options= []
    var left_args= []
    while(i<args.length){
        var arg= args[i]
        var rm_args= []
        if(arg.startsWith(optionPrefix) && arg.length>1){
            var joined_rest= args.slice(i).join(' ').slice(1)
            
            var opt_name=""
            var opt_val=""

            const _States={
                READ_OPT_NAME: 0,
                EXPECTING_EQ: 1,
                READ_OPT_VAL: 0b010,
                EXPECTING_END_QM: 0b100
            }

            var option= {name: ""}
            var state= _States.READ_OPT_NAME;
            var j= 0;
            while(j<joined_rest.length){
                var char= joined_rest[j]
                if(state===_States.READ_OPT_NAME){
                    if(char===' '){
                        state= _States.EXPECTING_EQ;
                    }
                    else if(char==='='){
                        state= _States.READ_OPT_VAL
                    }
                    else{
                        opt_name+= char;
                    }
                }
                else if(state===_States.EXPECTING_EQ){
                    if(char==='='){
                        state= _States.READ_OPT_VAL
                    }
                    else if(char!==' '){
                        ++j
                        break;
                    }
                }
                else if(state & _States.READ_OPT_VAL){
                    if(char==='"'){
                        if([' ','='].includes(joined_rest[j-1]) && !(state & _States.EXPECTING_END_QM)){
                            state= state | _States.EXPECTING_END_QM
                        }
                        else if((state & _States.EXPECTING_END_QM) && !(joined_rest.length>(j+1) && joined_rest[j+1]!==' ')){
                            ++j
                            break;
                        }
                        else{
                            opt_val+= char
                        }
                    }
                    else if(char===' '){
                        if(!(state & _States.EXPECTING_END_QM) && opt_val.length>0){
                            ++j
                            break;
                        }
                        else{
                            opt_val+= char
                        }
                    }
                    else{
                        opt_val+= char
                    }
                }

                ++j
            }

            option.name= opt_name;
            option['value']= (opt_val.length===0)?
                    (((state & _States.EXPECTING_END_QM) && joined_rest[j-1]==='"')?"":undefined)
                :   opt_val; 

            options.push(option)

            var ul=
                (joined_rest[j-1]===' ' || ((state & _States.EXPECTING_END_QM) && joined_rest[j-1]==='"') )?j-1
                : ((state===_States.EXPECTING_EQ) && joined_rest[j-2]===' ')? j-2    
                : j;
            rm_args= joined_rest.slice(0,ul).split(' ')
            // hereLog(`\t\trm_args: ${rm_args}`)
        }
        else{
            left_args.push(arg)
        }

        if(rm_args.length>0){
            i+= rm_args.length
        }
        else{
            ++i
        }
    }
    // return options

    return {options: options, args: left_args}
}


/**
 * from https://github.com/hydrabolt/discord.js/pull/641
 */
const MESSAGE_CHAR_LIMIT = 2000;
const splitString = (string, prepend = '', append = '') => {
    if (string.length <= MESSAGE_CHAR_LIMIT) {
        return [string];
    }

    const splitIndex = string.lastIndexOf('\n', MESSAGE_CHAR_LIMIT - prepend.length - append.length);
    const sliceEnd = splitIndex > 0 ? splitIndex : MESSAGE_CHAR_LIMIT - prepend.length - append.length;
    const rest = splitString(string.slice(sliceEnd), prepend, append);

    return [`${string.slice(0, sliceEnd)}${append}`, `${prepend}${rest[0]}`, ...rest.slice(1)];
};

class DataBaseManager{
    constructor(dbFilepath){
        this._db_path= dbFilepath

        this._db= null
        this._db_closeStamp= undefined

        this._cron_db_closer= cron.schedule('*/5 * * * *', () =>{
            if(Boolean(this._db_closeStamp) && ((Date.now()-this._db_closeStamp)>120000)
                && Boolean(this._db)
            ){
                this._db.close()
                hereLog("[DB_Manager]Closing database…")
                this._db= null
                this._db_closeStamp= undefined
            }
        });
    }

    _open_db(){
        if(!Boolean(this._db)){
            this._db_closeStamp= undefined
            this._db= new sqlite3.Database( this._db_path, (err) =>{
                if(err){
                    hereLog(err.message)
                    this._db_closeStamp= Date.now()-5000
                }
    
                hereLog(`[DB_Manager]Connection to ${this._db_path}`)
            })
        }
        else{
            this._db_closeStamp= undefined
        }
    }

    _closeRequest_db(){
        this._db_closeStamp= Date.now()
    }

    _is_db_open(){ return Boolean(this._db);}

    __runQuery(query, placeholders=[]){
        return new Promise((resolve, reject)=>{
            if(!this._is_db_open()) resolve(false);
            else{
                this._db.run(query,placeholders,(err)=>{
                    if(Boolean(err)){
                        hereLog(`[DB_Manager][RunQuery] query: ${query}; placeholders: ${placeholders}; error: ${err.message}`)
                        resolve(false);
                    }

                    resolve(true)
                })
            }
        })
    }

    __allQuery(query, fn, placeholders=[]){
        return new Promise((resolve, reject)=>{
            if(!this._is_db_open()) resolve(false);
            else{
                this._db.all(query, placeholders, async (err, rows)=>{
                    if(Boolean(err)){
                        hereLog(`[DB_Manager][eachQuery] query: ${query}; placeholders: ${placeholders}; error: ${err.message}`)
                        resolve(false);
                    }

                    if(Boolean(fn) && Boolean(rows)){
                        for(var row of rows){
                            await fn(row);
                        }
                    }

                    resolve(true);
                })
            }
        })
    }

    __getQuery(query,placeholders=[]){
        return new Promise((resolve, reject)=>{
            if(!this._is_db_open()) resolve(undefined);
            else{
            var t= this;
                this._db.serialize(function(){
                    t._db.get(query,placeholders,(err,row)=>{
                        if(Boolean(err)){
                            hereLog(`[DB_Manager][getQuery] query: ${query} ; placeholders: ${placeholders}; error: ${err.message}`)
                            resolve(undefined)
                        }
                        resolve(row)
                    })
                })
            }
        })
    }
}

module.exports.JSONCheck= JSONCheck;
module.exports.commandDecompose= commandDecompose;
module.exports.commandNameFromFilePath= commandNameFromFilePath;
module.exports.commandArgsOptionsExtract= commandArgsOptionsExtract;
module.exports.splitString= splitString;
module.exports.DataBaseManager= DataBaseManager;