
const path= require( 'path' );

const sqlite3 = require('sqlite3').verbose();
const cron= require('node-cron');


let hereLog= (...args) => {console.log("[utils]", ...args);};

JSONCheck ={
    VERSION: 0b1,
    BUILD: 0b10,

    TOKEN: 0b100,

    MASTERID: 0b1000,

    FULL_CHECK: 0b1111,

    availability: JSONobject => {
        let r= 0b0;

        let testEmptyFn= (str, CTRL) => { if(str.length>0) r= r | CTRL;}

        testEmptyFn(JSONobject.version, JSONCheck.VERSION);
        testEmptyFn(JSONobject.build, JSONCheck.BUILD);
        testEmptyFn(JSONobject.token, JSONCheck.TOKEN);

        let testMatchFn= (str, regex, CTRL) => {
            if((str.length>0) && (str.match(regex)!==null)) { r= r | CTRL;}
        }
        let idRegexMatch= /^[0-9]{18}$/;

        testMatchFn(JSONobject.masterID, idRegexMatch, JSONCheck.MASTERID);

        return r;
    },

    validity: JSONobject => {
        let r= JSONCheck.availability(JSONobject);

        return ( r === JSONCheck.FULL_CHECK );
    },

    report: JSONobject => {
        let r= JSONCheck.availability(JSONobject);

        if( r === JSONCheck.FULL_CHECK ){
            return "JSON Settings correctly available";
        }

        let str= "Error generated by: ";
        
        let reportConcat= (CTRL, fieldName) => {
            if ( !(r & CTRL) ){
                str+= "\n\tJSON settings - "+fieldName;
            }
        }

        reportConcat(JSONCheck.VERSION, "version");
        reportConcat(JSONCheck.BUILD, "build");
        reportConcat(JSONCheck.TOKEN, "token");
        reportConcat(JSONCheck.MASTERID, "masterID");

        return str;
    },
};

function commandDecompose(message, prefix='!'){
    if(!message.content.startsWith(prefix)){
        return null;
    }

    let splitCmd= message.content.substr(1).split(/[ ]+/);
    return {
        'command': splitCmd[0].toLowerCase(),
        'args': splitCmd.slice(1),
        'msg_obj': message,
    }
}

function commandNameFromFilePath(fpath){
    var cmd_name= path.basename(fpath);
    cmd_name= (cmd_name.startsWith("cmd_"))? cmd_name.slice(4) : cmd_name;
    cmd_name= (cmd_name.endsWith(".js"))? cmd_name.slice(0,-3) : cmd_name;

    return cmd_name;
}

function commandArgsOptionsExtract(args, optionPrefix='?'){
    var i=0;
    var options= {}
    var left_args= []
    while(i<args.length){
        var arg= args[i]
        var rm_args= []
        if(arg.startsWith(optionPrefix) && arg.length>1){
            var joined_rest= args.slice(i).join(' ').slice(1)
            
            var opt_name=""
            var opt_val=""

            const _States={
                READ_OPT_NAME: 0,
                EXPECTING_EQ: 1,
                READ_OPT_VAL: 0b010,
                EXPECTING_END_QM: 0b100
            }

            var option= {name: ""}
            var state= _States.READ_OPT_NAME;
            var j= 0;
            while(j<joined_rest.length){
                var char= joined_rest[j]
                if(state===_States.READ_OPT_NAME){
                    if(char===' '){
                        state= _States.EXPECTING_EQ;
                    }
                    else if(char==='='){
                        state= _States.READ_OPT_VAL
                    }
                    else{
                        opt_name+= char;
                    }
                }
                else if(state===_States.EXPECTING_EQ){
                    if(char==='='){
                        state= _States.READ_OPT_VAL
                    }
                    else if(char!==' '){
                        ++j
                        break;
                    }
                }
                else if(state & _States.READ_OPT_VAL){
                    if(char==='"'){
                        if([' ','='].includes(joined_rest[j-1]) && !(state & _States.EXPECTING_END_QM)){
                            state= state | _States.EXPECTING_END_QM
                        }
                        else if((state & _States.EXPECTING_END_QM) && !(joined_rest.length>(j+1) && joined_rest[j+1]!==' ')){
                            ++j
                            break;
                        }
                        else{
                            opt_val+= char
                        }
                    }
                    else if(char===' '){
                        if(!(state & _States.EXPECTING_END_QM) && opt_val.length>0){
                            ++j
                            break;
                        }
                        else{
                            opt_val+= char
                        }
                    }
                    else{
                        opt_val+= char
                    }
                }

                ++j
            }

            option.name= opt_name;
            option['value']= (opt_val.length===0)?
                    (((state & _States.EXPECTING_END_QM) && joined_rest[j-1]==='"')?"":undefined)
                :   opt_val; 

            if(Boolean(option.value)){
                options[option.name]= option.value
            }

            var ul=
                (joined_rest[j-1]===' ' || ((state & _States.EXPECTING_END_QM) && joined_rest[j-1]==='"') )?j-1
                : ((state===_States.EXPECTING_EQ) && joined_rest[j-2]===' ')? j-2    
                : j;
            rm_args= joined_rest.slice(0,ul).split(' ')
            // hereLog(`\t\trm_args: ${rm_args}`)
        }
        else{
            left_args.push(arg)
        }

        if(rm_args.length>0){
            i+= rm_args.length
        }
        else{
            ++i
        }
    }
    // return options

    return {options: options, args: left_args}
}


/**
 * from https://github.com/hydrabolt/discord.js/pull/641
 */
const MESSAGE_CHAR_LIMIT = 2000;
const splitString = (string, prepend = '', append = '') => {
    if (string.length <= MESSAGE_CHAR_LIMIT) {
        return [string];
    }

    const splitIndex = string.lastIndexOf('\n', MESSAGE_CHAR_LIMIT - prepend.length - append.length);
    const sliceEnd = splitIndex > 0 ? splitIndex : MESSAGE_CHAR_LIMIT - prepend.length - append.length;
    const rest = splitString(string.slice(sliceEnd), prepend, append);

    return [`${string.slice(0, sliceEnd)}${append}`, `${prepend}${rest[0]}`, ...rest.slice(1)];
};

class DataBaseManager{
    constructor(dbFilepath){
        this._db_path= dbFilepath

        this._db= null
        this._db_closeStamp= undefined

        this._cron_db_closer= cron.schedule('*/5 * * * *', () =>{
            if(Boolean(this._db_closeStamp) && ((Date.now()-this._db_closeStamp)>120000)
                && Boolean(this._db)
            ){
                this._db.close()
                hereLog("[DB_Manager]Closing databaseâ€¦")
                this._db= null
                this._db_closeStamp= undefined
            }
        });
    }

    _open_db(){
        if(!Boolean(this._db)){
            this._db_closeStamp= undefined
            this._db= new sqlite3.Database( this._db_path, (err) =>{
                if(err){
                    hereLog(err.message)
                    this._db_closeStamp= Date.now()-5000
                }
    
                hereLog(`[DB_Manager]Connection to ${this._db_path}`)
            })
        }
        else{
            this._db_closeStamp= undefined
        }
    }

    _closeRequest_db(){
        this._db_closeStamp= Date.now()
    }

    _is_db_open(){ return Boolean(this._db);}

    __runQuery(query, placeholders=[]){
        return new Promise((resolve, reject)=>{
            if(!this._is_db_open()) resolve(false);
            else{
                this._db.run(query,placeholders,(err)=>{
                    if(Boolean(err)){
                        hereLog(`[DB_Manager][RunQuery] query: ${query}; placeholders: ${placeholders}; error: ${err.message}`)
                        resolve(false);
                    }

                    resolve(true)
                })
            }
        })
    }

    __allQuery(query, fn, placeholders=[]){
        return new Promise((resolve, reject)=>{
            if(!this._is_db_open()) resolve(false);
            else{
                this._db.all(query, placeholders, async (err, rows)=>{
                    if(Boolean(err)){
                        hereLog(`[DB_Manager][eachQuery] query: ${query}; placeholders: ${placeholders}; error: ${err.message}`)
                        resolve(false);
                    }

                    if(Boolean(fn) && Boolean(rows)){
                        for(var row of rows){
                            await fn(row);
                        }
                    }

                    resolve(true);
                })
            }
        })
    }

    __getQuery(query,placeholders=[]){
        return new Promise((resolve, reject)=>{
            if(!this._is_db_open()) resolve(undefined);
            else{
            var t= this;
                this._db.serialize(function(){
                    t._db.get(query,placeholders,(err,row)=>{
                        if(Boolean(err)){
                            hereLog(`[DB_Manager][getQuery] query: ${query} ; placeholders: ${placeholders}; error: ${err.message}`)
                            resolve(undefined)
                        }
                        resolve(row)
                    })
                })
            }
        })
    }
}

function sleep(ms=1000){
    return new Promise(resolve => setTimeout(resolve, ms))
}

function DateFromTimeZone(dateString, timezone="Europe/Paris"){
    var baseDate= new Date(dateString)
    var tzPoVDate= new Date(baseDate.toLocaleString('en-US', {
        timeZone: timezone
    }))

    var diff= baseDate.getTime() - tzPoVDate.getTime()

    return new Date(baseDate.getTime() + diff)
}



function identifyEmoji(str, utils){
    let simpleEmojiRegex= /(?:[\u2700-\u27bf]|(?:\ud83c[\udde6-\uddff]){2}|[\ud800-\udbff][\udc00-\udfff]|[\u0023-\u0039]\ufe0f?\u20e3|\u3299|\u3297|\u303d|\u3030|\u24c2|\ud83c[\udd70-\udd71]|\ud83c[\udd7e-\udd7f]|\ud83c\udd8e|\ud83c[\udd91-\udd9a]|\ud83c[\udde6-\uddff]|\ud83c[\ude01-\ude02]|\ud83c\ude1a|\ud83c\ude2f|\ud83c[\ude32-\ude3a]|\ud83c[\ude50-\ude51]|\u203c|\u2049|[\u25aa-\u25ab]|\u25b6|\u25c0|[\u25fb-\u25fe]|\u00a9|\u00ae|\u2122|\u2139|\ud83c\udc04|[\u2600-\u26FF]|\u2b05|\u2b06|\u2b07|\u2b1b|\u2b1c|\u2b50|\u2b55|\u231a|\u231b|\u2328|\u23cf|[\u23e9-\u23f3]|[\u23f8-\u23fa]|\ud83c\udccf|\u2934|\u2935|[\u2190-\u21ff])/g;
    let customEmojiRegex= /^<\:([a-zA-Z\-_0-9]+)\:([0-9]{18})>$/;

    var _tmp= undefined;
    var emojiType= undefined;
    hereLog(`[identifyEmoji] ${str}`)
    try{
        emojiType= ( Boolean(str) )? (
                Boolean(str.match(simpleEmojiRegex))? {type: "SIMPLE", emoji: str, text: str} :
                    ( Boolean(str) && Boolean(_tmp=str.match(customEmojiRegex))? 
                            {   type: "CUSTOM",
                                emoji: utils.getBotClient().emojis.cache.get(_tmp[2]),
                                text: str
                            }
                        : undefined) 
            ) : undefined;
    }
    catch(err){
        hereLog(`[identifyEmoji] error: ${err.message}`)
        emojiType= undefined;
    }

    return emojiType;
}

module.exports.JSONCheck= JSONCheck;
module.exports.commandDecompose= commandDecompose;
module.exports.commandNameFromFilePath= commandNameFromFilePath;
module.exports.commandArgsOptionsExtract= commandArgsOptionsExtract;
module.exports.splitString= splitString;
module.exports.DataBaseManager= DataBaseManager;
module.exports.sleep= sleep;
module.exports.DateFromTimeZone= DateFromTimeZone;
module.exports.identifyEmoji= identifyEmoji;